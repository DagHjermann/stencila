<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
  <main>
    <div id="data" data-format="html">
      <div class="content">
        <div data-title="">Stencila Manual</div>
        <p>Stencila Documents are designed for <em>reproducibility</em>. An important aspect of reproducibility is <em>readability</em>. Code cells in Stencila Documents use a simple expression language called Mini. Mini is meant to be only slightly more advanced than the expressions that you write in your calculator or into the cell of a spreadsheet.</p>
        <h2>Value types</h2>
        <p>Mini has a simple type system that is similar to most high level languages. Each type can be constructed using literals...</p>
        <table>
          <tr>
            <td>Type</td>
            <td>Example literal</td>
          </tr>
          <tr>
            <td>null</td>
            <td><code>null</code></td>
          </tr>
          <tr>
            <td>boolean</td>
            <td><code>true, false</code></td>
          </tr>
          <tr>
            <td>integer</td>
            <td><code>1, 2, 42</code></td>
          </tr>
          <tr>
            <td>float</td>
            <td><code>3.13</code></td>
          </tr>
          <tr>
            <td>array</td>
            <td><code>[1, 2, 3]</code></td>
          </tr>
          <tr>
            <td>object</td>
            <td><code>{ a: 1, b: '2'}</code></td>
          </tr>
          <tr>
            <td>my_custom_type</td>
            <td><code>{ type: 'my_custom_type', ...}</code></td>
          </tr>
        </table>
        <h1>Tabular data </h1>
        <p>Tabular data is an important part of data analysis</p>
        <div data-cell="data = table({
species: {type: 'nominal', values: concat(repeat('setosa',50), repeat('versicolor',50), repeat('virginica',50))},
sepal_length: {values: [5.1,4.9,4.7,4.6,5,5.4,4.6,5,4.4,4.9,5.4,4.8,4.8,4.3,5.8,5.7,5.4,5.1,5.7,5.1,5.4,5.1,4.6,5.1,4.8,5,5,5.2,5.2,4.7,4.8,5.4,5.2,5.5,4.9,5,5.5,4.9,4.4,5.1,5,4.5,4.4,5,5.1,4.8,5.1,4.6,5.3,5,7,6.4,6.9,5.5,6.5,5.7,6.3,4.9,6.6,5.2,5,5.9,6,6.1,5.6,6.7,5.6,5.8,6.2,5.6,5.9,6.1,6.3,6.1,6.4,6.6,6.8,6.7,6,5.7,5.5,5.5,5.8,6,5.4,6,6.7,6.3,5.6,5.5,5.5,6.1,5.8,5,5.6,5.7,5.7,6.2,5.1,5.7,6.3,5.8,7.1,6.3,6.5,7.6,4.9,7.3,6.7,7.2,6.5,6.4,6.8,5.7,5.8,6.4,6.5,7.7,7.7,6,6.9,5.6,7.7,6.3,6.7,7.2,6.2,6.1,6.4,7.2,7.4,7.9,6.4,6.3,6.1,7.7,6.3,6.4,6,6.9,6.7,6.9,5.8,6.8,6.7,6.7,6.3,6.5,6.2,5.9]},
sepal_width: {values: [3.5,3,3.2,3.1,3.6,3.9,3.4,3.4,2.9,3.1,3.7,3.4,3,3,4,4.4,3.9,3.5,3.8,3.8,3.4,3.7,3.6,3.3,3.4,3,3.4,3.5,3.4,3.2,3.1,3.4,4.1,4.2,3.1,3.2,3.5,3.6,3,3.4,3.5,2.3,3.2,3.5,3.8,3,3.8,3.2,3.7,3.3,3.2,3.2,3.1,2.3,2.8,2.8,3.3,2.4,2.9,2.7,2,3,2.2,2.9,2.9,3.1,3,2.7,2.2,2.5,3.2,2.8,2.5,2.8,2.9,3,2.8,3,2.9,2.6,2.4,2.4,2.7,2.7,3,3.4,3.1,2.3,3,2.5,2.6,3,2.6,2.3,2.7,3,2.9,2.9,2.5,2.8,3.3,2.7,3,2.9,3,3,2.5,2.9,2.5,3.6,3.2,2.7,3,2.5,2.8,3.2,3,3.8,2.6,2.2,3.2,2.8,2.8,2.7,3.3,3.2,2.8,3,2.8,3,2.8,3.8,2.8,2.8,2.6,3,3.4,3.1,3,3.1,3.1,3.1,2.7,3.2,3.3,3,2.5,3,3.4,3]}
})"></div>
        <h1>Plotting</h1>
        <p>The <code>plot</code> function takes tabular data, ....</p>
        <div data-cell="plot(data, 'points', 'sepal_length', 'sepal_width')"></div>
        <p>Can set plot options of the Vega-Lite spec....</p>
        <div data-cell="plot(data, 'points', 'sepal_length', 'sepal_width', color='species', options={
  encoding:{
    color:{
      legend:{title:'Species name'}
    }
  }
})"></div>
        <p>Or use convieniece functions like <code>title</code> to set options.</p>
        <div data-cell="titles(points(data, 'sepal_length', 'sepal_width', color='species'), color='Species name')"></div>
        <h2>Using other languages</h2>
        <p>An important feature of Mini is its ability to interoperate with other languages. Mini can act as a glue language - for those times when you need to combine the strengths of several languages. For example, you might want to extract some data from a database using Structured Query Language (SQL), then perform a specialised statistical analysis on the data using R, then visualise the results using Mini's built in plotting functions.</p>
        <p>Mini makes this possible through alternative execution contexts. Each context knows how to convert values to and from the Mini value types and how to execute snippets of code in the context's native language. The <code>JsContext</code> (for executing JavaScript code) comes embedded in the browser or desktop window of your Stencila Document.</p>
        <p>Within the browser window of a Stencila Document there is a Stencila Host. A Host is responsible for finding, and talking to, other Hosts and orchestrating parts of the platform. Every few seconds your browser Host looks for other Hosts being served within other processes running on your computer. (In the future you'll also be able to manually register both local and remote peers.) When a peer Host is found, a handshake is performed and the hosts exchange manifests of their capabilities. One of those is capabilities is a list of the classes of Stencila Contexts that the Host supports.</p>
        <p>Stencila Contexts share a common interface for executing code, whatever the language. They are very similar to Jupyter's &amp;quot;kernels&amp;quot; (a Stencila Context for bridging to Jupyter kernels is planned). The Stencila language packages each have one or more class of Context. The following subsections provide instructions on how to download those packages and start the Host so that you can start using those contexts.</p>
        <h3>Node.js</h3>
        <p>Install the Stencila package for Node.js via NPM, <code>npm install -g stencila-node</code>, then start the host by running <code>stencila-node</code> in the system shell. If you've done that, this cell should show the Node.js version that you are running (if you need to, press <code>Ctrl+Enter</code> within the source of the cell to refesh it)</p>
        <div data-cell="run()" data-language="node">
          <pre data-source="">process.title + ' ' + process.version</pre>
        </div>
        <h3>Python</h3>
        <p>Install the Stencila package for Python, <code>pip install --user https://github.com/stencila/py/archive/master.zip</code>, then start the host by running the package's main script, <code>python -m stencila</code> or within a Python console using <code>stencila.host.start()</code> . If you've done that, this cell should show the Python version that you are running:</p>
        <div data-cell="run()" data-language="py">
          <pre data-source="">import sys
sys.version</pre>
        </div>
        <p>In addition to having a PythonContext class, the Python package also has a SQLiteContext for executing code within SQLite:</p>
        <div data-cell="run()" data-language="sqlite">
          <pre data-source="">SELECT sqlite_version();</pre>
        </div>
        <h3>R</h3>
        <p>Install the Stencila package for R using devtools, devtools::install_github(&amp;quot;stencila/r&amp;quot;), then start the host by running Rscript -e &amp;quot;stencila::run()&amp;quot; at the system shell or &amp;quot;stencila::host$start()&amp;quot; within your favorite R console. If you've done that, this cell should show the R version that you are running: </p>
        <div data-cell="run()" data-language="r">
          <pre data-source="">R.version.string</pre>
        </div>
        <p>There are two special functions in Mini for executing code in other languages: <code>run()</code> and <code>call()</code>. </p>
        <h3>The <code>run</code> function</h3>
        <p>The <code>run</code> function executes code within the execution's global context. Using the <code>run</code> function is very similar to using code cells in Jupyter notebooks or code chunks in RMarkdown. When you assign a variable within the cell it is available to be used within a different cell later in the document. However, you need to take care of dependencies yourself, so if you change the source code of the first cell, you need to re-execute the second cell that depends on it.</p>
        <p>Here's an example. Let's assign a global variable within a <code>JsContext</code> :</p>
        <div data-cell="run()" data-language="js">
          <pre data-source="">myGlobal = 42
</pre>
        </div>
        <p>Now, <code>myGlobal</code> is a data/time object that is available to use in any cell. Let's look at it using another <code>run</code> cell:</p>
        <div data-cell="run()" data-language="js">
          <pre data-source="">myGlobal</pre>
        </div>
        <h3>The <code>call</code> function</h3>
        <p>The <code>call</code> function executes code within a function scope. That means that any variables that you declare within that function are local to the function and won't leak into the context's global scope. So, when you type <code>call()</code> into a cell, your effectively saying to Mini take this code, make it into a function, execute the function, and give me back the value. Here's an example of a simple <code>call</code> to some Javascript:</p>
        <div data-cell="call()" data-language="js">
          <pre data-source="">let names = ['Hiphop', 'opotamus', ' v ', 'Rhyme', 'noceros']
return names.join('')</pre>
        </div>
        <p>Notice that because we ended the JavaScript code, with a <code>return</code> statement that the cell has an output. When you <code>call()</code> some JavaScript <code>code</code> it's like executing <code>(function(){code})()</code>. The same is true for other external languages, it's just that the syntax differs.</p>
        <p>Just like with other Mini cells, you can assign the output of a <code>call()</code> to a document variable,</p>
        <div data-cell="javascript_pi = call()" data-language="js">
          <pre data-source="">return Math.PI</pre>
        </div>
        <p>A call to another language is not very useful unless you provide it with some data. This is where Mini's glueing comes in. Let's create an array in Mini,</p>
        <div data-cell="fruits = ['apple', 'pear', 'kiwi']"></div>
        <p>and then use Javascript to join it together.</p>
        <div data-cell="call(fruits)" data-language="js">
          <pre data-source="">return 'My favourite fruits: ' + fruits.map((fruit,index) =&gt; {
    return `${index + 1}. ${fruit}`
}).join(', ')</pre>
        </div>
        <p>The nice thing about this is that Mini's dependency analysis still works, so you can change the fruits array and the output above will change - try it! </p>
        <p>Notice that our Javascript function got supplied an argument called <code>fruits</code> - which is the same array of strings as in our document variable called <code>fruits</code>. You can also provide named arguments to <code>call</code>.</p>
        <div data-cell="call(my_favourite_fruits = fruits, index = 2)" data-language="js">
          <pre data-source="">return my_favourite_fruits[index]</pre>
        </div>
        <p>Here's an example, that puts this all together with an input, a Javascript call cell and an output to display the result...</p>
        <p>The area of a circle can be calculated by <span data-math="asciimath">a = pi r^2</span> . So, if the radius of a circle is <input type="range" name="radius" min="0" max="100" step="1" value="60"></input> m, then it's area is: <span data-cell="area">11309.733552923255</span> m<sup>2</sup>.</p>
        <div data-cell="area = call(r=radius)" data-language="js">
          <pre data-source="">return Math.PI*Math.pow(r, 2)</pre>
        </div>
        <p></p>
      </div>
    </div>
  </main>
</body>
</html>
