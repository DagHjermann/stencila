#! /usr/bin/env python
# encoding: utf-8

from configuration import *

def options(context):
	pass

def configure(context):
	# Determine which versions of Python are installed
	import os
	versions = []
	for version in (
		'2.5','2.6','2.7',
		'3.1','3.2','3.3','3.4'
	):
		# See if it exists
		if os.path.exists(py_include(context.env.SYSTEM,version)): versions.append(version)
	print 'Found Python versions: ',', '.join(versions)
	context.env.PYTHON_VERSIONS = versions

def build(context):
	system = context.env.SYSTEM

	src = context.path.get_src()
	bld = context.path.get_bld()
	for version in context.env.PYTHON_VERSIONS:
		# Absolute path for this version's build
		version_dir = '%s/%s'%(bld.abspath(),version)

		#Create a list of source file, object file pairs
		pairs = []
		# Stencila C++ module source files
		for cpp in src.parent.find_dir('cpp').ant_glob('stencila/*.cpp'):
			pairs.append((
				cpp,
				'%s/objects/cpp/%s'%(version,str(cpp).replace('.cpp','.o'))
			))
		# Stencila Python module source files
		for cpp in src.ant_glob('stencila/*.cpp'):
			if str(cpp)!='extension.cpp':
				pairs.append((
					cpp,
					'%s/objects/%s'%(version,str(cpp).replace('.cpp','.o'))
				))

		# Compile object files
		includes = [
			py_include(system,version)
		]
		for cpp,obj in pairs:
			context(
				rule = '${CXX} --std=c++11 -fPIC -c -o ${TGT} %s ${SRC}'%(
					' '.join('-I%s'%item for item in includes),
				),
				source = cpp,
				target = obj
			)

		objs = [obj for cpp,obj in pairs]

		# Copy setup.py and configuration.py to version build directory so they can be used from there
		for filename in ['setup.py','configuration.py']:
			context(
				rule = 'cp ${SRC} ${TGT}',
				source = filename,
				target = '%s/%s'%(version,filename),
			)

		# Copy module files to version build directory so they can be used by
		# setup.py
		for filename in ['__init__.py','context.py','extension.cpp']:
			context(
				rule = 'cp ${SRC} ${TGT}',
				source = 'stencila/%s'%filename,
				target = '%s/stencila/%s'%(version,filename),
			)

		# Run setup.py in version build directory and record the 
		# name of the wheel to file for reading by other
		# build tasks
		context(
			name = 'py-setup-%s'%version,
			cwd = version_dir,
			rule = '''
				export STENCILA_VERSION=${STENCILA_VERSION}
				python%s setup.py bdist_wheel
				echo `ls -rt dist/*.whl | tail -n1` > setup-latest.txt
			'''%version,
			# Sources are object files and 
			source = objs + [
				'%s/stencila/__init__.py'%version,
				'%s/stencila/context.py'%version,
				'%s/stencila/extension.cpp'%version,
				'%s/setup.py'%version,
				'%s/configuration.py'%version
			],
			# Target is file with wheel name
			target = '%s/setup-latest.txt'%version
		)

		# Create a virtual environment to be used for testing with the Python version
		# Using a virtual environment allows the Stencila wheel to be installed locally,
		# i.e. without root privalages, and also does not affect the host machines Python setup 
		# Waf does not remove the directory structure on `./waf clean` which causes issues with
		# the virtual env setup. So force removal here.
		context(
			name = 'py-testenv-%s'%version,
			cwd = version_dir,
			rule = '''
				rm -rf testenv
				virtualenv --python=python%s --no-site-packages testenv
			'''%version,
			# Target is virtual enviroment activate script
			target = '%s/testenv/bin/activate'%version
		)

		# Get the name of the extension module for this system and Python version
		extension_name = py_extension_name(system,version)
		# Determine path to compiled extension module
		extension_path = '%s/testenv/lib/python%s/site-packages/stencila/%s'%(version,version,extension_name)

		# Activate testenv and install latest Stencila wheel there
		context(
			name = 'py-install-%s'%version,
			cwd = version_dir,
			rule = '''
				. testenv/bin/activate
				pip install --upgrade --force-reinstall `cat setup-latest.txt`
			''',
			# Source is virtual enviroment activate script and file with name of
			# latest Stencila Python package
			source = [
				'%s/testenv/bin/activate'%version,
				'%s/setup-latest.txt'%version
			],
			# Target is the installed extension module
			target = extension_path
		)

		# Activate testenv, run tests in it and send output to file
		context(
			name = 'py-test-%s'%version,
			cwd = version_dir,
			rule = '''
				. testenv/bin/activate
				python ${SRC[1].abspath()} 2>&1 | tee test-output.txt
			''',
			# Source is the installed extension module and the tests.py source file
			source = [
				extension_path,
				'tests/tests.py'
			],
			# Target is the test output
			target = '%s/test-output.txt'%version
		)
